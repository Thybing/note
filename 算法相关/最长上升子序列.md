# 最长上升子序列

最长上升子序列问题是一道经典的线性DP题目

## 问题描述

洛谷 B3637
给定一个无序的整数数组，找出其中的最长上升子序列的长度。

## 问题分析

### 暴力解题

对于一般的求子序列的问题，我们有着最暴力的求解方法，利用二进制枚举枚举出所有的可能性，然后再对枚举的结果加以判断。
显然的，这种方法的时间复杂度为O(2^n)，我们可以利用DFS很容易的实现这种写法。

[暴力求解](./最长上升子序列_0.cpp)

### 线性DP

对于一个数组，我们取它的一个前缀数组进行此问题的求解。很显然，后续的数据不会对a1的最长上升子序列的结果做出干扰。所以这个问题具有无后效性。
接下来，我们来思考如何快速在增加数据时通过已求解出的信息，来计算出数据量扩大时的问题的解。

(做这道题的时候的思路复现？)
思考1：
假设我们现在已有数组a0，我们新添加了一个数据x，此时，x会不会更新我们的最长上升子序列长度，取决于x会不会被新的最长上升子序列所选中。

思考1.0：
我们是否可以存储a0的最长上升子序列的末尾last？并且让x与last进行比较，从而得到x是否会使得子序列加长？
答：不可以，由于有可能会出现多个相同长度的不同结尾的的子序列。

思考1.1：
那么是否可以在所有可能的last中取最小值进行存储？
答：当然可以，这样的话我们可以轻易的通过last和x进行比较，来判断答案是否需要+1。但是问题是，我们该如何去维护这个最小的last？

思考1.2：
对于新加入的x，可能不会进入a0的最长上升子序列中。但是对于a1(a1 = a0 + x)，考虑一组长度为当前答案长度-1的序列。后续追加了x之后，形成了一组新解，并且显然，新解的最后一位是x，并且x小于a0的last。
答：由此，a1的last不能只由a0的last得出。无法进行维护。

思考1.3：
求解出新的序列a1的last需要什么？
如果x大于a0的last，显然的，x是a1的last。并且ans++。
否则，我们需要得知是否存在一个长度a0的答案-1的序列，并且序列的末位小于x。如果存在，则a1的last是x，如果不存在，则a1的last是a0的last。

思考1.4：
能否做到刚刚的要求？
考虑为a0中每一个a[i]都存储一个l[i]，l[i]代表以元素a[i]结尾的最长的上升序列的长度。(l此时为len的缩写)
有了l[i]，我们可以遍历a0和l数组，寻找是否有满足思考1.3中所提出的条件。此步骤的复杂度为O(n)

思考1.5：
l数组如何维护？即插入x之后如何维护x在l数组对应的值，假设是l[n+1]吧
首先，很显然l数组满足无后效性。
l[n+1]初始化为1，然后，遍历已有的a0数组，在a[i]小于x的情况下，l[n+1] = max(l[n+1],l[i] + 1)。
即为，初始长度为1，如果前面有序列的末尾小于x，即可添加一个x，构成新的l[n+1]的候选。最后选择最大的。
此步骤的复杂度为O(n)

综合以上。我们可以以O(n)的复杂度进行一次递推，维护last和l数组。

所以，通过以上算法，我们可以以O(n^2)的时间复杂度和O(n)的空间复杂度来求解此问题。

思考1.6：
对于思考1.3的“如果x大于a0的last，显然的，x是a1的last。并且ans++。”的情况
显然的，如果x是a1的last，那么在求解l[n+1]时，l[n+1]对应的序列就是a1的最长上升子序列。
所以，我们无需维护last并且如思考1.3中进行两种情况的分类。通过维护l数组可以直接涵盖。

综上:
我们可以维护一个数组l，其中l[i]代表以a[i]结尾的，最长上升子序列的长度。
最后取l数组中的最大值，即得到问题的解。

[动态规划求解](./最长上升子序列_1.cpp)

### 二分

考虑一个数组b，b[i]是长度为i的上升子序列的末尾元素中最小的元素。
显然的，b数组严格递增

我们从前到后遍历原数组，每一轮遍历中拿到的元素为a
我们可以在b数组找到大于等于元素a的第一个元素b[i],(lower_bound)
如果找到了，就说明长度为i的子序列的末尾最小值可以更新为元素a，即使b[i] = a
如果没找到，就说明元素a可以与原先末尾元素为b.back()构成一组更长的子序列。b[++len] = a
最终答案为len

此方法在寻找lower_bound时，所需的时间复杂度为O(logn)
总时间复杂度为O(nlogn)

[二分求解](./最长上升子序列_2.cpp)

# 红黑树

首先，红黑树是一种自平衡的二叉树。它的查找的时间复杂度为O(logn)。相比于平衡二叉树AVL对树高的严格限制，红黑树对于树高的限制比较宽松，因此整体来说，红黑树不如AVL树平衡，所以必然的查找效率会略低于AVL，（尽管它们都是logn）。但是，由于AVL树对于平衡性的严格要求，导致插入删除操作时需要大量的旋转调整操作，此时红黑树的优势就明显的体现出来。所以，红黑树要相比avl树应用的更加广泛。

一棵合法的红黑树必须遵循以下四条性质：

1. 节点为红色或黑色
2. NIL 节点（空叶子节点）为黑色
3. 红色节点的子节点为黑色
4. 从根节点到 NIL 节点的每条路径上的黑色节点数量相同

## 增删改查

### 插入节点



### 删除节点

#### case-1：特殊情况，如果只有一个根节点，直接删除。

#### case0：删除的节点只有左/右孩子

左/右孩子代替del节点(以下将所有要删除的节点简称为del节点),并且替代后染黑

说明:如果del节点是红色,则孩子为黑色,则有孩子这路必然超过一个黑节点(null算黑),没有孩子的另一路必然只有一个null为黑节点,违反性质4,故可以证明del节点不可能为红色。
类似的,根据性质4可以推断出,在这种情况下del节点的子节点必然是红节点，且为叶子节点。那么得出上述调整方案就非常简单了。（可以理解为将红孩子节点的数据移动至del节点，并且删除此红孩子）

#### case1：删除的节点同时有左右孩子

这种情况下，参考二叉搜索树的方法，先找到该del节点的后继/前驱节点，然后将其数据移动至del节点(不改变del节点的链接关系和颜色)。现在就转化为了删除del节点的后继/前驱节点（并且容易得出，该前驱/后继一定不会同时有左右孩子，即转化为了case0或者case2）。

#### case2：删除的节点没有孩子

##### case2-0：删除的节点是红节点

直接删除，不违反任何性质

##### case2-1：删除的节点是黑色节点

看兄弟的颜色（注，黑节点一定会有兄弟，否则违反性质4）

##### case2-1-0：兄弟的颜色是黑色

再看兄弟的孩子，即侄子。

##### case2-1-0-0：有红色侄子

观察父兄红侄的位置形态：

##### case2-1-0-0-0：父兄红侄构成顺链

即父兄红侄构成LL/RR（有两个红侄的情况也包含在内，所以应该优先判断这种情况）
变色：
红侄变黑（如果两个红侄，仅变色处于顺链上的）
兄变为父色
父变黑
旋转：
以父节点为旋转点，向del节点旋转

##### case2-1-0-0-1：父兄红侄构成反链

即父兄红侄构成LR/RL
变色：
红侄变为父色
父变黑
旋转：
以兄弟为旋转点，将反链调整为顺链
以父作为旋转点，向del节点旋转

##### case2-1-0-1：没有红色侄子

注：此时准确说是没有侄子(仅有两个黑色的空节点)。因为如果有黑色侄子会破坏性质4

变色：
兄变为红色

如果父为红色，直接将父变黑

如果父为黑色(如果父节点是根节点，则结束调整)，将父作为待调整节点进行调整。

##### case2-1-1：兄为红节点

变色：
兄变黑
父变红
旋转：
以父为旋转中心，向del节点旋转

这种情况下，可以推断出，旋转前必然有两个黑色侄子。所以旋转后对于del节点，一定呈现出黑兄（原先的一个侄子）。则转化为2-1-0来进行调整。

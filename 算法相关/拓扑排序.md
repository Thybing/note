# 拓扑排序

给定一个有向无环图(DAG)，如果从 i 到 j 有边，则认为 j 依赖于 i。如果 i 到 j 有路径（i 可达 j），则称 j 间接依赖于 i。
拓扑排序的目标是将其中的所有节点进行排序，并且使得排在前面的节点不会依赖或间接依赖于后面的节点。

## 算法实现

目前针对于拓扑排序，有两种常用的方法，Kahn算法和DFS算法。

### Kahn（卡恩）算法

Kahn算法算是一种宽搜策略
核心为维护一个队列q，其中记录着所有的入度为0的顶点。
为了快速获取顶点的入度，我们可以为每个顶点维护一个变量来记录。

重复以下三步操作直到q为空
从q中取出一个顶点v0排到现有的拓扑排序的序列末尾。
然后枚举依赖于v0的所有节点v，将v的入度减一
如果v的入度为0，那么将其加入q中

注意，如果我们不保证图是一个DAG，那么可以检查一下上述方法得出的排序长度是否为顶点个数。如果不等，说明原图不是一个DAG。

[cpp实现](./拓扑排序_卡恩算法.cpp)

#### 复杂度分析

显然的我们需要将所有节点添加进拓扑序列中
并且在循环中对于入度的总维护次数为边数
所以时间复杂度为O(V + E)

### DFS算法

对于一个顶点v0，我们如果想要去将其添加到序列中，为了保证性质，我们需要将所有依赖于v0的顶点都置于v0之后再去添加。
为了方便，我们不妨先去得到所求拓扑序列的逆序列。即我们在添加v0前，需要先添加好所有依赖或者间接依赖v0的顶点。
很显然，这里我们可以使用DFS。
DFS函数功能为向序列中添加顶点v0。并且如果有依赖与v0的顶点，就先调用DFS函数添加到序列中。
另外，为了防止重复添加，我们要记录好已经被添加到序列中的顶点。
如果搜索到我们的节点已经被添加进去了（能被搜索到说明已经被添加进去的节点是依赖正在dfs的节点的，不违反我们正在求的逆序列的性质），那么跳过这个节点。

我们对所有的节点均调用一次DFS，然后就得到了所求的逆序列。

最后将该序列进行reverse即可得到满足性质的拓扑序列。

注意，如果不能保证原图是一个DAG，那么会出现什么情况？如果有环，那么在进行DFS入环时，就会出现DFS搜索到正在进行DFS调用的顶点本身。
所以我们可以设置为节点设置一种中间状态，即除了未访问和已添加，还可以添加一种搜索中的状态。如果DFS时搜到了搜索中状态的节点，说明搜索路径成环。

[cpp实现](./拓扑排序_DFS.cpp)

#### 复杂度分析
分析过程类似Kahn，同样是O(V + E)

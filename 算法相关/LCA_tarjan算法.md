# LCA_tarjan算法

解释的有点抽象，希望未来我能看懂？

tarjan算法是一种求解lca问题的离线算法。
离线算法是基于「求解前已知所有数据」这一假设来设计的，适用于有多组询问的题目。对于本算法来说，即需要提前知道所有的询问。

## 算法前置(个人对于tarjan算法求lca的理解)

首先，假如现在有一棵树，并且有一组询问lca(u,v)，让我们想一个最简单的lca算法。
很容易想到，我们可以对以节点u为根的子树进行搜索，如果发现了v，那么u就是lca(u,v)，
如果没有找到v，那么我们对以节点u的父节点u'为根的子树进行搜索，
以此方式令u'不断向根节点进行迭代。直到搜索到了v，那么当前正在搜索的u'就是lca(u,v)

这应该是最为暴力求解lca的方法了吧。

但是，如果出现了多组查询，每一组查询都要经过如上的暴力求解，算法的时间复杂度效率很显然十分低下。

那么，能不能对上述的算法做一些改进呢？能不能在一次暴力搜索时，找到所有的询问的解答呢？我认为这就是tarjan算法的核心思想。

首先，依旧是对这棵树进行DFS。

假如对树中的一个节点进行DFS(后根)，这个节点有若干以孩子为根的子树（下面简称子树）。
每当一颗子树搜索完成时，就令这颗子树中所有的节点都有的一个指针，指向该节点。代表该节点是这些子节点们在进行DFS过程中，最新一次回溯到的祖先(每一个节点默认指向自己)。
打上标记，代表这些节点已经被访问过。
然后在DFS搜索下一颗子树(相对右边的子树)时，假设正在访问节点v，并且有一组lca(u,v)的询问。并且u是我们已经标记访问过的。
那么我们只需要看节点u中的指针此刻指向的节点，就是lca(u,v)的结果。

如何理解？
假如我们现在在对答案节点a进行深搜，
深搜完节点a的左子树(不一定是二叉树，左右是相对的)的时候，左子树的所有节点指向a，其中的u就指向a，
我们再去搜索右子树（v在其中），找到v之后，查询u指向的结果，就是a。

如果u还没有指向a，指向的是a中左子树的后代，那么显然DFS是不可能找到v的。因为v在a的右子树。
如果u已经指向a的祖先了，那么很显然曾经u一定是指向过a的，v一定是在u指向a的时候被搜索到。
综上，只有u在指向a的时刻，我们才可能在DFS中搜索到v。

节点a本身是u或v的情况。也同样满足上述的叙述。

## 算法实现

对于上面的每一个节点中的指针指向自己正在DFS的祖先，我们发现用并查集可以完美的描述。
首先维护一个并查集。然后维护一个visited数组。
然后以后根遍历DFS查询的树。
对于一个节点a，DFS其每个子树，然后将子树中节点所在集合与a节点的集合合并，并且指向a节点。
搜索完所有子树之后，将visited[a]设置为true，然后我们查看一下有关节点a的询问，假如有lca(a,b)的询问。
如果visited[b]为true，说明被访问过，那么找到并查集中b所处的集合的根，即为结果。

[LCA_tarjan算法](./LCA_tarjan算法.cpp)

## 复杂度分析
DFS遍历树时间复杂度O(V)
假设维护和查询并查集的复杂度为O(1)
那么每次查询结果的复杂度为O(1)
所有查询的时间复杂度我O(q),q是询问的次数。
所以总时间复杂度为O(V + q)

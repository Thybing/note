# LCA算法（最近公共祖先）-树上倍增

LCA算法用来计算出树上的两个节点的最近公共祖先。

## 算法实现

首先我们有一个数组，存储着每一个节点所处的深度deeps[i]。
然后我们还有一个二维数组fas(fathers)[i][j]，存储着每一个节点的若干个祖先节点。
具体要求是，fas[i][j]存储着i节点向上的第(2^j)的祖先(如果是不存在的祖先，那么就存储同一个哨兵即可)
例如
fas[i][0],存储着i节点的父节点(向上一层)
fas[i][1],存储着i节点的祖父节点(向上2层)
fas[i][2],存储着i节点的祖父节点的祖父节点(向上4层)
这样，如果我们想找到节点i向上任意层数的祖先，我们只需要向上最多跳跃logm次即可，m是树的高度。(一般我们直接将m开到20)

然后对于节点u和v，我们先找到较低(靠近叶子节点)的节点，例如节点u是更低的节点(如果v更低就将uv进行swap，方便处理)
根据deep数组可以很容易确定uv的高度差，
然后根据fas数组找到节点u与v同层的祖先作为u'(可以是u本身)
然后，如果v本身是uv的lca，那么u’和v是同一个节点。结束查找。

否则的话，令k从m到0，判断fas[u][k]是否等于fas[v][k]
如果相等，continue。
如果不相等，令u = fas[u][k],v = fas[v][k]

最后，u和v一定是亲兄弟。
然后取u的父节点，即是最原始的uv的LCA

另外，对于fas数组的构建，很显然可以利用动态规划。
首先，初始化fas[i][0]，就是找到每一个节点的父节点。（为了方便代码实现，这里我们将0号节点当作哨兵，并且0号节点的父节点还是0号节点）
然后，对于fas[i][1],就是找i的父节点的父节点,即fas[i][1] = fas[fas[i][0]][0]
对于fas[i][2],同理容易得到fas[i][2] = fas[fas[i][1]][1]

即状态转移方程为fas[i][k] = fas[fas[i][k - 1]][k - 1]
初始条件为所有的fas[i][0]
fas[0][k]全部为0，即哨兵向上任意层祖先都是本身

## cpp代码

[LCA_树上倍增](./LCA_树上倍增.cpp)

## 复杂度分析
首先，对于fas数组的构建为O(logM * N),N为节点个数，M为树的最大高度，一般oi竞赛中直接取logM = 20
然后，每一次查询，两种跳跃操作每一种均最多跳跃logM次。查询的复杂度为O(logM)

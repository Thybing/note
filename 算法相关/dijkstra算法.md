# dijkstra算法

dijstra算法是求解从单一源点到其它所有节点最短路径的算法。但是此算法不能适用具有负权重边的图中。

## 算法实现

dijkstra算法是一种贪心策略。
每次找到未被标记过的距离源点路径最近的顶点V，然后标记该顶点，最后对该顶点相邻的未标记顶点做一次松弛操作并记录路径。

## cpp实现（朴素实现）

维护一个数组dis，存储每一个节点通过已标记的节点到源点的距离。初始为INF，源点到自己为0。
维护一个数组from，存储节点为以dis到达源点的上一个节点。
维护一个数组visited，用来标记已经求解过的点。

遍历数组dis，找到其中的最小值，将对应的顶点V0的visited置位。
遍历V0相邻的节点eachV，如果是标记过的则跳过，否则对比一下经过V0到eachV的路径是否比原先的更优。
如果更优，更新dis和from。
循环以上步骤，直到所有的节点都被visited过。如果找出的最小值为INF，则说明该图不是一个连通图。

[dijkstra算法](./dijkstra算法_0.cpp)

## 复杂度分析

首先是朴素实现

要重复V次添加，并且每一次添加时要遍历所有节点找最小值。很显然这里的复杂度为O(V^2)
然后对于所有的维护操作，维护的总次数是边的数量，复杂度是O(E)
所以朴素实现的时间复杂度为O(V^2 + E)
又因为E最大不会超过V^2
所以这里可以直接将该算法的时间复杂度写为O(V^2)

空间复杂度为O(V)，需要开辟与定点数相同的空间用于存储状态。

# dijkstra算法

dijkstra算法是求解从单一源点到其它所有节点最短路径的算法。但是此算法不能适用具有负权重边的图中。

## 算法实现

dijkstra算法是一种贪心策略。
每次找到未被标记过的距离源点路径最近的顶点V，然后标记该顶点，最后对该顶点相邻的未标记顶点做一次松弛操作并记录路径。

## cpp实现（朴素实现）

维护一个数组dis，存储每一个节点通过已标记的节点到源点的距离。初始为INF，源点到自己为0。
维护一个数组from，存储节点为以dis到达源点的上一个节点。
维护一个数组visited，用来标记已经求解过的点。

遍历数组dis，找到其中的最小值，将对应的顶点V0的visited置位。
遍历V0相邻的节点eachV，如果是标记过的则跳过，否则对比一下经过V0到eachV的路径是否比原先的更优。
如果更优，更新dis和from。
循环以上步骤，直到所有的节点都被visited过。如果找出的最小值为INF，则说明该图不是一个连通图。

[dijkstra算法](./dijkstra算法_0.cpp)

## cpp实现（堆优化版）

维护的数组和上面相同。

堆优化版的dijkstra，其重点在于优化了找未被标记过的距离源点路径最近的顶点V的过程。
很显然，对于找一个集合内的最值的问题，我们可以选择维护一个堆来快速的寻找目标。

这里我们去向堆中插入一个pair类型，其中first是该顶点到源点的长度，second是该顶点。

首先我们向堆h内添加源点。
然后直到所有的顶点都被标记，循环以下操作
从堆h内取出堆顶的pair，查看其中的顶点是否已经被标记，如果已经被标记，跳过。否则将其标记。
每当我们标记一个顶点后，尝试用其所有出边对相邻顶点进行松弛操作，如果成功松弛，那么将松弛之后的路径长度和顶点的pair插入到堆中。

[dijkstra算法_堆优化](./dijkstra算法_1.cpp)

## 复杂度分析

首先是朴素实现

要重复V次添加，并且每一次添加时要遍历所有节点找最小值。很显然这里的复杂度为O(V^2)
然后对于所有的维护操作，维护的总次数是边的数量，复杂度是O(E)
所以朴素实现的时间复杂度为O(V^2 + E)
又因为E最大不会超过V^2
所以这里可以直接将该算法的时间复杂度写为O(V^2)

空间复杂度为O(V)，需要开辟与定点数相同的空间用于存储状态。

对于堆优化版本的dijkstra

每一条边都会遍历到并可能松弛后插入到堆中，所以复杂度为O(ElogE)

空间复杂度为O(V + E)

所以，由此可见，如果是稀疏图，E约等于V，那么堆优化版本的dj是O(VlogV)的复杂度，要远远好于朴素版本的O(V^2)
但是，如果是稠密图，E约等于V^2，那么堆优化版本的复杂度就变成了O(V^2 * log(V ^ 2))，反而要比朴素版本慢

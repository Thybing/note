# prim算法

prim算法是求最小生成树的算法。

## 算法实现
其核心思想为贪心。
取最短连接的节点加入树中，并将此边加入树中。直到所有的节点被加入树中，就构建出了最小生成树。

## 朴素写法实现，利用遍历找到最近的点

### 实现过程
首先有一个visited数组，visited[i]代表了第i个节点是否已经加入了树中
然后有一个mincost数组，mincost[i]代表了第i个节点到树中某个节点的最短路径长度。(如果不存在直接相连的边则为INF)
最后有一个father数组，father[i]存储着可能的第i个节点暂时最优的父节点
father数组是为了在整个prim算法结束之后，去构建出这棵树用的。即father[i]是i的父节点。(双亲表示法)

初始化：visited数组全部复位。mincost数组全部设为INF。father数组全部设为-1

确定一个根节点。然后将根节点加入。
每次加入之后都需要维护上述的三个数组。

假设加入第i个节点时的维护操作:
将visited[i]置位
遍历与第i个节点相连接的节点，如果是未加入的节点（假设为j节点），那么将mincost[j]与该边Edge(i,j)作比较，如果发现Edge(i,j)更短，那么更新mincost[j]为Edge(i,j)的长度，并且节点j的最优父节点为节点i,更新father[j] = i。

然后，还剩节点数-1个节点待加入。

重复(节点数-1)次
每次一先遍历mincost，找到最小的mincost[i]。
然后加入节点i，然后如上维护上面的三个数组。
(注意，这里我们找到的mincost[i],就是我们添加进去的Edge(i,fa[i])的长度，如果需要的话，可以存储下来)

### 复杂度分析
循环了numVertix次
每次循环中需要遍历一遍mincost找到下一个加入的节点，也是numVertix次
所以O(V^2),其中V为numVertix。
并且每一次循环之后会有一次维护数组。
维护的复杂度是O(e),e是本次插入节点的所连接其它节点数量
所以对每一次循环的O(e)进行求和，显然是总Edge数的两倍。花费是O(E),E 是图的边数。
所以时间复杂度是O(V^2 + E)

又因为V^2 > E(在稠密图中，E约等于V^2)
所以总时间复杂度可以直接写为O(V^2)


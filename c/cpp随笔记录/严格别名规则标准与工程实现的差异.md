# strict-alias规则标准与工程实现中的差异

注：随笔记录，随时可能理解错误，有问题请指正。

## 先贴一个平时可能会写出来且看似没有问题的代码

```c
#include <stdio.h>
#include <stdint.h>

void cpy128(void *dst, const void *src) {
  const uint8_t *s = (const uint8_t*)src;
  uint8_t *d = (uint8_t*)dst;
  typedef uint32_t byte32;
  for (int i = 0; i < 16; i+=4)
    *(byte32*)(d + i) = *(const byte32*)(s + i);
}

int main(void) {
  float A[4] = {1, 2, 3, 4};
  float B[4] = {5, 6, 7, 8};

  cpy128(B, A);
  for (int i = 0; i < 4; i++)
    printf("%f ", B[i]);
  return 0;
}
```
编译，运行，输出1,2,3,4符合预期。
开个O2优化试试？
编译运行：1,0,0,0
？？？？？

(个人实验环境mingw64，gcc version 8.1.0，c11标准，不过感觉这个结果受版本影响不大就是了)

## freertos kernel
本文所用的内核版本为github当前最新提交(ccabdec2f8c2cb8c7740e018546a53a3e6e0ef22)

在学习freertos的源码的过程中，我读到了一段freertos kernel中链表的源码

下面这段定义了链表item结构和链表结构
```c
struct xLIST_ITEM
{
    listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE           /**< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    configLIST_VOLATILE TickType_t xItemValue;          /**< The value being listed.  In most cases this is used to sort the list in ascending order. */
    struct xLIST_ITEM * configLIST_VOLATILE pxNext;     /**< Pointer to the next ListItem_t in the list. */
    struct xLIST_ITEM * configLIST_VOLATILE pxPrevious; /**< Pointer to the previous ListItem_t in the list. */
    void * pvOwner;                                     /**< Pointer to the object (normally a TCB) that contains the list item.  There is therefore a two way link between the object containing the list item and the list item itself. */
    struct xLIST * configLIST_VOLATILE pxContainer;     /**< Pointer to the list in which this list item is placed (if any). */
    listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE          /**< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
};
typedef struct xLIST_ITEM ListItem_t;

#if ( configUSE_MINI_LIST_ITEM == 1 )
    struct xMINI_LIST_ITEM
    {
        listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE /**< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
        configLIST_VOLATILE TickType_t xItemValue;
        struct xLIST_ITEM * configLIST_VOLATILE pxNext;
        struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;
    };
    typedef struct xMINI_LIST_ITEM MiniListItem_t;
#else
    typedef struct xLIST_ITEM      MiniListItem_t;
#endif

/*
 * Definition of the type of queue used by the scheduler.
 */
typedef struct xLIST
{
    listFIRST_LIST_INTEGRITY_CHECK_VALUE      /**< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    configLIST_VOLATILE UBaseType_t uxNumberOfItems;
    ListItem_t * configLIST_VOLATILE pxIndex; /**< Used to walk through the list.  Points to the last item returned by a call to listGET_OWNER_OF_NEXT_ENTRY (). */
    MiniListItem_t xListEnd;                  /**< List item that contains the maximum possible item value meaning it is always at the end of the list and is therefore used as a marker. */
    listSECOND_LIST_INTEGRITY_CHECK_VALUE     /**< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
} List_t;
```

在list定义中我们可以看到，xListEnd是链表中的哨兵节点，它的类型取决于用户的配置。如果我们不启用configUSE_MINI_LIST_ITEM，哨兵节点的类型将和正常节点相同，为xLIST_ITEM，没有任何问题。但是如果启用它，注意哨兵节点的类型将会与正常节点不同，为xMINI_LIST_ITEM。

然后我们再来看一段对于链表的初始化操作片段
```c
void vListInitialise( List_t * const pxList )
{
    ......
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );
    ......
    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );

    /* Initialize the remaining fields of xListEnd when it is a proper ListItem_t */
    #if ( configUSE_MINI_LIST_ITEM == 0 )
    {
        pxList->xListEnd.pvOwner = NULL;
        pxList->xListEnd.pxContainer = NULL;
        listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );
    }
    #endif
    ......
}
```

这里我们可以看到，无论是否启用了mini-list-item，代码中都使用指针强制转换，将哨兵节点的指针使用ListItem_t来解释。我们观察前面两个结构体，发现它具有公共的初始序列，在主流编译器的结构体内存布局策略下，这种访问方式完全可以访问到我们期望的内存。这时就形成了类型双关，难道有什么问题吗？

先来说一下严格别名规则。
别名，简单说就是如果多个左值表达式同时指向了同一块地址区域，那么这些左值表达式就形成了别名。
严格别名规则，就是说别名需要与实际的对象满足一定条件，它才可以被认为是一个合法的别名，看一下C标准草案中对于这个合法的限定：
```
An object shall have its stored value accessed only by an lvalue expression that has one of
the following types:
— a type compatible with the effective type of the object,
— a qualified version of a type compatible with the effective type of the object,
— a type that is the signed or unsigned type corresponding to the effective type of the
object,
— a type that is the signed or unsigned type corresponding to a qualified version of the
effective type of the object,
— an aggregate or union type that includes one of the aforementioned types among its
members (including, recursively,amember of a subaggregate or contained union), or
— a character type.
```
大概就是：
同类型访问
加 const/volatile 访问
有符号/无符号变种
再加 const/volatile
通过包含该类型的 struct/union，例如struct中包含了一个int，我们可以在代码中用int*指向这个int创造别名
字符类型可以访问任意对象字节

所以显然的，对于底层是xMINI_LIST_ITEM的哨兵节点对象，用xLIST_ITEM的指针去解释并访问它，实际上违反了严格别名规则。这是一种类型双关，但在C标准下是一个UB行为。

为什么有严格别名规则？这与编译器优化有关：对于不同的别名，编译器会在一定条件下认为它们分别指向不同的内存，进而优化出效率更高的代码。例如，编译器会认为对于float指针指向的内存进行操作，不会影响到一个int指针所指向的内存，而产生一定的优化。

所以freertos错了吗？从严格的C标准上来说它确实是UB行为。但是类型双关是使用C语言编程，尤其是嵌入式编程中经常使用的技巧(个人认为嵌入式代码中很容易找到这种程度上不遵循严格别名的写法)。freertos是目前最主流的两个rtos之一，它的内核代码经过数十年的验证，保证了稳定性和可移植性，编写freertos的人也肯定是知道这里在C标准上是UB。工程和C标准中出现了冲突时，与标准较劲的意义不大。我们可以去试着寻找一个满足标准的工程实现，当然也可以遵循编译器的实现标准。

当然，这里的意思并不是鼓励编程的时候多多使用，重点是我们要知道我们在做什么，尽量避免写出UB的代码，如果因为某些原因如性能要求，必须要这样实现，那么可能会发生什么问题，如果发生了问题要如何解决。例如，假如一段内存可以被两个结构体解释，可以新建一个结构体然后利用memcpy拷贝过来，使用完成后再拷贝回原来的内存，这是一种合法的类型双关，但是面临着效率降低的问题。或者使用union，c标准(cpp不行)中，如果union包含多个结构体有公共初始序列，那么公共初始序列的部分，可以由任何一个成员所访问(当然非公共初始序列的部分访问了还是UB)。如下是一个合法的类型双关例子。
```c
union {
    struct {
        int alltypes;
    } n;

    struct {
        int type;
        int intnode;
    } ni;

    struct {
        int type;
        double doublenode;
    } nf;
} u;

u.nf.type = 1;
u.nf.doublenode = 3.14;
/* ... */
if (u.n.alltypes == 1)
        if (sin(u.nf.doublenode) == 0.0)
            /* ... */
```
或者直接将编译器利用严格别名规则的优化关掉 （-fno-strict-aliasing）也是一种解决方案。  

又或者可以依赖编译器扩展，如gcc提供了may_alias，它明确的告诉了编译器，被修饰的内容可能打破严格别名，不要做严格别名优化。
另外gcc对union做类型重解释也做了扩展，利用union做类型重解释是完全合法的，如：
```c
union foo {
    int i;
    float f;
};
float x;
union foo u;
u.i = 123;
x = u.f;
```
实际上在linux内核中也经常使用这种方法。
我们可以看到linus在邮件中喷标准缺陷[https://lkml.org/lkml/2018/6/5/769](https://lkml.org/lkml/2018/6/5/769)


**最后再说一下观点**
了解严格别名规则是为了尽量写出稳定可靠的代码，而不是当标准律师。写这篇记录只是因为在看freertos源码的过程中突然想起来这个问题，仔细查阅了一下，现在将查阅的结论记录下来而已。我完全认同freertos的写法，也认同linus邮件中的观点。回忆起来我个人就写出过UB的类型双关代码，有时正确运行，有时候在强制转换的地方出现了莫名其妙的bug，虽然当时我没有意识到可能是严格别名导致的问题。

## glibc中的BSDsocket

// TODO(这里主要看一下GCC对strict-alias-rule相关扩展的使用。自己的库用自己的编译器扩展和实现标准当然合理，只能说是和c标准有差异(应该早点转正，尤其是may_alias))
